trả lời bằng tiếng việt
viết đoạn code python tính cosine similarity theo ý tưởng: ma trận cosine similarity là bằng tổng total tích vô hướng của các ma trận con của ma trận đầu vào cần tính 
   -với cách xử lý sau: đọc từ file kích thước của ma trận đầu vào(bên dưới là file input mẫu), chia ma trận đầu vào thành các submatrix(ma trận con) phù hợp với kích thước của ma trận đầu vào
input mẫu để check logic
4 3 #kích thước của ma trận đầu vào
3 4 1
2 4 5
4 4 2
4 5 6
output mẫu để check logic
1.0000 0.9771 0.8257
0.9771 1.0000 0.8932
0.8257 0.8932 1.0000

các thư viện được phép dùng:
    threading
    multiprocessing
    concurrent.futures
    asyncio
    joblib
    string
    re
    collections
    queue
    math
    cmath
    decimal
    fractions
    random

YÊU CẦU CAO NHẤT: CHẠY ĐÚNG KẾT QUẢ, CHẠY NHANH VÀ DƯỚI 20S RUNTIME VỚI TRƯỜNG HỢP MA TRẬN ĐẦU VÀO 10^6 X 10^3, không dùng thư viện ngoài, cấm dùng GPU


Here is the English translation of your request:

---

**Write a Python script to calculate the normalization based on the following idea**:  
The cosine similarity matrix is obtained as the total sum of dot products of submatrices of the input matrix to be computed.  

### Requirements:
1. **Submatrix Partitioning**:  
   - Divide the input matrix into submatrices, where each submatrix has rows and columns equal to \( \log(N \times M) \), with \( N \) as the number of rows and \( M \) as the number of columns of the original matrix.  
   - The set of \( n \) submatrices will form a *chunk*, where each core processes a chunk in parallel. The number of chunks = the number of processes.  

2. **Stream Processing**:  
   - Read and process the input matrix directly from the file, computing the result as you read.  
   - Do not store the entire input matrix in a variable to process later, as the input size may be very large and cause memory overflow.  

3. **Direct Writing**:  
   - Write results directly into the result matrix as computations are completed.  
   - Avoid using intermediate variables or iterating over the original matrix afterward.  

4. **Dot Product Calculation**:  
   - Use `inner_product` for the dot product of submatrices.  

5. **Library Restrictions**:  
   - Do **not** use NumPy or any external libraries.  

6. **Parallelism**:  
   - The machine has a maximum of 10 cores to leverage parallel processing.  

### Input Example:
```
4 3
3 4 1
2 4 5
4 4 2
4 5 6
```

### Output Example:
```
1.0000 0.9771 0.8257
0.9771 1.0000 0.8932
0.8257 0.8932 1.0000
```

### Additional Notes:
- **Performance Requirement**:  
  The code must produce the correct result and execute in under **20 seconds** for an input matrix of size \( 10^6 \times 10^3 \).  
- **Hardware Constraints**:  
  - No use of GPU.  
  - Only the following libraries are allowed:
    ```
    threading
    multiprocessing
    concurrent.futures
    asyncio
    joblib
    string
    re
    collections
    queue
    math
    cmath
    decimal
    fractions
    random
    ```